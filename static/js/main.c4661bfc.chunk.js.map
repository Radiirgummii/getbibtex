{"version":3,"sources":["generateCitation.ts","App.js","reportWebVitals.js","index.js"],"names":["bibtexFromEntryData","entryData","currentDate","moment","format","title","website","replace","citekey","parseResult","parseDomain","type","ParseResultType","Listed","domain","words","split","firstWords","numWords","i","length","charAt","toUpperCase","slice","firstWordsFromTitle","createCiteKey","author","url","domainFromUrl","match","getCitation","a","process","proxyUrl","urlMetadata","then","metadata","bibtex","App","useState","setUrl","bibtexEntry","setBibtexEntry","setEntryData","copy","useClipboard","loading","setLoading","copied","setCopied","useEffect","timer","setTimeout","clearTimeout","style","marginBottom","justify","span","maxWidth","y","h1","label","href","h4","placeholder","width","value","onChange","e","target","disabled","onClick","className","position","minHeight","top","right","zIndex","borderColor","padding","iconRight","color","auto","size","fontStyle","date","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c4661bfc.chunk.js","sourcesContent":["import urlMetadata from 'url-metadata'\nimport {parseDomain, ParseResultType} from \"parse-domain\";\nimport moment from 'moment'\n\ninterface EntryData {\n    title: string,\n    author: string,\n    url: string,\n    website: string,\n}\n\nfunction firstWordsFromTitle(title: string): string {\n    let words = title.split(\" \")\n    let firstWords = \"\"\n    let numWords = 0\n    for (const i in title.split(\" \")) {\n        if (words[i].length >= 4 && numWords < 2) {\n            firstWords = firstWords + words[i].charAt(0).toUpperCase() + words[i].slice(1) // capitalize first letter in word\n            numWords += 1\n        }\n    }\n    return firstWords\n}\n\nfunction createCiteKey(entryData: EntryData): string {\n    let citekey: string = \"\"\n    const parseResult = parseDomain(entryData.website)\n    if (parseResult.type === ParseResultType.Listed) {\n        const { domain } = parseResult\n        citekey = \"\" + domain\n    }\n    citekey = citekey + firstWordsFromTitle(entryData.title)\n    citekey = citekey.replace(/\\W/g, '') // remove non-alphanumeric characters\n    return citekey\n}\n\nfunction bibtexFromEntryData(entryData: EntryData): string {\n    // TODO: check if there are no invalid characters for bibtex\n    const currentDate = moment().format(\"DD-MMM-YYYY\")\n    const title = upperLettersInBibTex(`${entryData.title} --- ${entryData.website}`)\n    let bibtex: string = `@misc{${createCiteKey(entryData)},\n\\tauthor = {${entryData.author}},\n\\ttitle = {${title}},\n\\thowpublished = {\\\\url{${entryData.url}}},\n\\tyear = {},\n\\tnote = {[Accessed ${currentDate}]},\n}`\n    return bibtex\n}\n\nfunction upperLettersInBibTex(str: string): string {\n    return str.replace(/([A-Z])/g, '{$1}')\n}\n\nfunction domainFromUrl(url: string): string {\n    // based on regular expression https://regex101.com/r/MOIFTy/3\n    const domainRegex = /^(?:https?:)?(?:\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^:/\\n]+)/\n    const match = url.match(domainRegex)\n    let domain: string = ''\n    if (match != null) {\n        domain = match[1]\n    }\n    return domain\n}\n\n\nconst getCitation = async (url: string) => {\n    const proxyServerUrl = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8080/'\n    const proxyUrl = proxyServerUrl+url\n    return urlMetadata(proxyUrl).then(\n    metadata => { // success handler\n        const domain = domainFromUrl(url)\n        const entryData: EntryData = {\n            title: metadata.title,\n            author: metadata.author,\n            url: url,\n            website: domain,\n        }\n        return entryData\n    },\n    ).then(\n        entryData => {\n            let bibtex: string = bibtexFromEntryData(entryData)\n            return {bibtex, entryData}\n        }\n    )\n}\n\nexport { \n    getCitation, \n    firstWordsFromTitle, \n    createCiteKey, \n    upperLettersInBibTex, \n    domainFromUrl, \n    bibtexFromEntryData\n}","import './App.css'\nimport { GeistProvider, CssBaseline, useClipboard, Row, Col, Input, Spacer, Button, Textarea, Text, Note } from '@geist-ui/react'\n\nimport { useEffect, useState } from 'react'\nimport { getCitation } from './generateCitation'\nimport { Copy, Check } from '@geist-ui/react-icons'\nimport moment from 'moment'\n\nconst App = () => {\n  const [url, setUrl] = useState('')\n  const [bibtexEntry, setBibtexEntry] = useState('')\n  const [entryData, setEntryData] = useState()\n  const { copy } = useClipboard()\n  const [loading, setLoading] = useState(false)\n  const [copied, setCopied] = useState(false)\n\n  const handleUrlChange = (e) => {\n    setUrl(e.target.value)\n  }\n\n  const handleButtonClicked = (e) => {\n    setLoading(true)\n    getCitation(url, setBibtexEntry).then(({ bibtex, entryData }) => {\n      setBibtexEntry(bibtex)\n      setEntryData(entryData)\n      setLoading(false) // will this work on error promise?\n    })\n  }\n\n  const handleCopyClicked = () => {\n    copy(bibtexEntry)\n    // set checkmark in button\n    setCopied(true)\n  }\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setCopied(false)\n    }, 1500)\n    return () => clearTimeout(timer)\n  }, [copied])\n\n  return (\n    <GeistProvider>\n      <CssBaseline />\n      <Row style={{ marginBottom: '15px' }} justify='center'>\n        <Col span={22} justify='center' style={{ maxWidth: '38em' }}>\n          <Spacer y={2} />\n          <Text h1>BibTex generator from URL</Text>\n          <Spacer y={2} />\n          <Note label='USE NEW ADDRESS' type='error'>The application is moved to <a href=\"https://url-to-bibtex.vercel.app/\">url-to-bibtex.vercel.app</a></Note>\n          <Spacer y={2} />\n          <Text h4>Enter the URL below: </Text>\n          <Input placeholder='URL to website/article' width='100%' value={url} onChange={handleUrlChange} disabled={true} />\n          <Spacer y={0.5} />\n          <Row justify='center'>\n            <Button loading={loading} onClick={handleButtonClicked} type='secondary' style={{ width: '100%' }}>Generate BibTex entry</Button>\n          </Row>\n          <Spacer y={0.5} />\n          <div className='output' style={{ position: 'relative' }}>\n            <Textarea placeholder='' width='100%' minHeight='23em' value={bibtexEntry} onChange={(e) => setBibtexEntry(e.target.value)} />\n            <Button style={{ position: 'absolute', top: '5px', right: '5px', zIndex: 33, borderColor: copied ? 'green' : '', padding: '0 0.5rem' }} iconRight={copied ? <Check color='green' /> : <Copy />} auto size='small' onClick={handleCopyClicked} />\n          </div>\n          {entryData != null &&\n            <span>\n              <span>{entryData?.author && entryData?.author + '. '}</span>\n              <span style={{ fontStyle: 'italic' }}>{entryData?.title + ' --- ' + entryData?.website + '. '} </span>\n              <a href={entryData?.url}>{entryData?.url}</a>,\n              <span> {entryData?.date && entryData?.date + '. '}</span>\n              <span>[Accessed {moment().format('DD-MMM-YYYY')}]</span>\n            </span>}\n        </Col>\n      </Row>\n    </GeistProvider>\n  )\n}\n\nexport default App\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry)\n      getFID(onPerfEntry)\n      getFCP(onPerfEntry)\n      getLCP(onPerfEntry)\n      getTTFB(onPerfEntry)\n    })\n  }\n}\n\nexport default reportWebVitals\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}